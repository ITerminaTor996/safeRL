================================================================================
Task FSA 扩展计划
基于 LTL 公式的任务分解与引导
================================================================================

一、目标与动机
================================================================================

1.1 当前问题
------------
- 现有框架只支持单一目标（到达 T 点）
- 无法表达顺序任务（先到 A，再到 B，最后到 C）
- 任务目标硬编码在环境中，缺乏灵活性

1.2 期望效果
------------
用户只需在配置文件中定义：
1. 原子命题（哪些位置/区域有意义）
2. Safety 公式（不能做什么）—— 硬约束
3. Task 公式（要做什么）—— FSA 引导

框架自动：
- 解析公式生成 FSA
- 追踪任务进度
- 提供阶段性奖励
- 将进度信息加入观测

1.3 设计原则
------------
- Safety 和 Task 分离：Safety 用硬约束，Task 用 FSA 引导
- 配置驱动：换场景只需改配置，不改代码
- 模块复用：LTL 解析、FSA 生成、Robustness 计算都是通用的


二、架构设计
================================================================================

2.1 整体架构
------------

┌─────────────────────────────────────────────────────────────────┐
│                        config.yaml                               │
├─────────────────────────────────────────────────────────────────┤
│  atomic_propositions:          # 原子命题定义                    │
│    checkpoint_a: {pos: [2,3]}                                    │
│    checkpoint_b: {pos: [4,2]}                                    │
│    danger: {region: [[1,1],[1,2]]}                               │
│                                                                  │
│  safety:                       # 安全约束（硬约束）              │
│    formula: "G(!wall) & G(!danger)"                              │
│                                                                  │
│  task:                         # 任务目标（FSA 引导）            │
│    formula: "F(checkpoint_a & F(checkpoint_b & F(goal)))"        │
│    # 含义：先到 a，再到 b，最后到 goal                           │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    原子命题管理器 (PropositionManager)           │
│  - 从配置加载命题定义                                            │
│  - 评估状态是否满足命题                                          │
│  - 计算命题的 robustness                                         │
└─────────────────────────────────────────────────────────────────┘
                              ↓
        ┌─────────────────────┴─────────────────────┐
        ↓                                           ↓
┌───────────────────────┐               ┌───────────────────────┐
│   Safety Monitor      │               │   Task FSA Monitor    │
│   (现有，硬约束)       │               │   (新增，软引导)       │
│                       │               │                       │
│ - 检查动作安全性       │               │ - 追踪 FSA 状态       │
│ - 过滤不安全动作       │               │ - 检测状态转移        │
│ - 计算安全 robustness  │               │ - 提供转移奖励        │
└───────────────────────┘               └───────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    SafeEnvWrapper (扩展)                         │
│  观测 = [局部视野] + [当前目标方向] + [FSA 状态编码]             │
│  奖励 = r_task + r_safety + r_fsa_transition + r_robustness      │
└─────────────────────────────────────────────────────────────────┘


2.2 FSA 状态转移示例
--------------------

任务公式: F(a & F(b & F(goal)))
含义: 先到 a，再到 b，最后到 goal

生成的 FSA:
    
    ┌─────┐  到达a   ┌─────┐  到达b   ┌─────┐  到达goal  ┌─────────┐
    │ q0  │ ───────→ │ q1  │ ───────→ │ q2  │ ─────────→ │ accept  │
    └─────┘          └─────┘          └─────┘            └─────────┘
      ↑                ↑                ↑
      └── 其他 ────────┴── 其他 ────────┘

状态含义:
- q0: 还没到 a
- q1: 已到 a，还没到 b
- q2: 已到 a 和 b，还没到 goal
- accept: 任务完成

奖励设计:
- q0 → q1: +2 (到达第一个检查点)
- q1 → q2: +2 (到达第二个检查点)
- q2 → accept: +10 (完成任务)


2.3 观测空间设计
----------------

方案 A: FSA 状态 one-hot 编码
    obs = [local_view(25), goal_dir(2), fsa_state_onehot(n)]
    
    优点: 简单直接
    缺点: FSA 状态数变化时维度变化

方案 B: 当前子目标方向 (推荐)
    obs = [local_view(25), current_subgoal_dir(2), progress(1)]
    
    current_subgoal_dir: 指向当前需要到达的目标
    progress: 已完成的子目标数 / 总子目标数
    
    优点: 维度固定，语义清晰
    缺点: 需要从 FSA 状态推断当前子目标

方案 C: 混合
    obs = [local_view(25), current_subgoal_dir(2), fsa_state_id(1)]
    
    fsa_state_id: 当前 FSA 状态的整数编号


三、模块设计
================================================================================

3.1 PropositionManager (扩展 propositions.py)
---------------------------------------------

class PropositionManager:
    """
    管理所有原子命题的定义和评估
    """
    
    def __init__(self, config: dict, env_info: dict):
        """
        从配置加载命题定义
        
        config 示例:
        {
            'wall': 'auto',
            'goal': 'auto',
            'checkpoint_a': {'type': 'position', 'pos': [2, 3]},
            'danger': {'type': 'region', 'positions': [[1,1], [1,2]]}
        }
        """
        pass
    
    def evaluate(self, state: tuple, prop_name: str) -> bool:
        """评估状态是否满足命题"""
        pass
    
    def get_robustness(self, state: tuple, prop_name: str) -> float:
        """计算命题的 robustness"""
        pass
    
    def get_all_true_props(self, state: tuple) -> set:
        """获取当前状态下所有为真的命题"""
        pass


3.2 TaskFSAMonitor (新增 task_monitor.py)
-----------------------------------------

class TaskFSAMonitor:
    """
    基于 FSA 的任务进度监控器
    """
    
    def __init__(self, task_formula: str, prop_manager: PropositionManager):
        """
        解析任务公式，生成 FSA
        """
        self.formula = task_formula
        self.fsa = self._build_fsa(task_formula)
        self.current_state = self.fsa.initial_state
        self.prop_manager = prop_manager
    
    def step(self, agent_state: tuple) -> dict:
        """
        根据当前状态更新 FSA
        
        Returns:
            {
                'fsa_state': 当前 FSA 状态,
                'transition': 是否发生转移,
                'transition_reward': 转移奖励,
                'is_accepting': 是否到达接受状态,
                'current_subgoal': 当前子目标位置,
                'progress': 任务进度 (0-1)
            }
        """
        pass
    
    def reset(self):
        """重置到初始状态"""
        self.current_state = self.fsa.initial_state
    
    def get_current_subgoal(self) -> tuple:
        """获取当前需要到达的子目标位置"""
        pass


3.3 SafeEnvWrapper (扩展)
-------------------------

class SafeEnvWrapper(gym.Wrapper):
    
    def __init__(self, env, safety_formula, task_formula=None, ...):
        # 现有的安全监控
        self.safety_monitor = SafetyMonitor(...)
        self.action_filter = ActionFilter(...)
        
        # 新增：任务 FSA 监控
        if task_formula:
            self.task_monitor = TaskFSAMonitor(task_formula, ...)
        else:
            self.task_monitor = None
    
    def _get_obs(self, base_obs):
        """扩展观测空间"""
        if self.task_monitor:
            # 添加当前子目标方向和进度
            subgoal = self.task_monitor.get_current_subgoal()
            subgoal_dir = self._compute_direction(agent_pos, subgoal)
            progress = self.task_monitor.get_progress()
            return np.concatenate([base_obs, subgoal_dir, [progress]])
        return base_obs
    
    def step(self, action):
        # 1. 安全过滤（现有）
        filtered_action = self.action_filter.filter(action)
        
        # 2. 执行动作
        obs, reward, done, truncated, info = self.env.step(filtered_action)
        
        # 3. 更新任务 FSA（新增）
        if self.task_monitor:
            task_info = self.task_monitor.step(agent_pos)
            reward += task_info['transition_reward']
            done = done or task_info['is_accepting']
            info.update(task_info)
        
        # 4. 扩展观测
        obs = self._get_obs(obs)
        
        return obs, reward, done, truncated, info


四、配置文件设计
================================================================================

# config.yaml 完整示例

environment:
  map_path: "maps/map_with_checkpoints.txt"
  view_size: 5

# 原子命题定义
atomic_propositions:
  # 环境自动提供
  wall: "auto"
  goal: "auto"
  boundary: "auto"
  
  # 用户自定义检查点
  checkpoint_a:
    type: "position"
    pos: [2, 3]
    
  checkpoint_b:
    type: "position"
    pos: [4, 2]
  
  # 用户自定义危险区域
  danger_zone:
    type: "region"
    positions: [[1, 1], [1, 2], [2, 1]]

# 安全约束（硬约束，绝对保证）
safety:
  enabled: true
  formula: "G(!wall) & G(!boundary) & G(!danger_zone)"
  unsafe_penalty: -1.0

# 任务目标（FSA 引导，软目标）
task:
  enabled: true
  formula: "F(checkpoint_a & F(checkpoint_b & F(goal)))"
  # 含义：先到 checkpoint_a，再到 checkpoint_b，最后到 goal
  
  # 奖励设置
  transition_reward: 2.0      # 每次 FSA 状态转移的奖励
  completion_reward: 10.0     # 完成任务的奖励
  use_robustness_shaping: true  # 是否使用 robustness 做奖励塑形

# 训练设置
training:
  total_timesteps: 50000
  # ...


五、实现计划
================================================================================

阶段 1: 扩展原子命题系统 (1-2小时)
----------------------------------
1. 修改 propositions.py
   - 支持从配置加载命题定义
   - 支持 position 和 region 类型
   - 统一 robustness 计算接口

2. 更新 config.yaml 格式

3. 测试原子命题系统

阶段 2: 实现 Task FSA Monitor (2-3小时)
---------------------------------------
1. 新建 safe_rl_drone/task/task_monitor.py
   - 解析任务公式
   - 生成 FSA（使用 Spot）
   - 实现状态转移逻辑
   - 实现子目标提取

2. 测试 FSA 生成和转移

阶段 3: 扩展 SafeEnvWrapper (1-2小时)
-------------------------------------
1. 集成 TaskFSAMonitor
2. 扩展观测空间
3. 添加 FSA 转移奖励
4. 更新终止条件

阶段 4: 测试与验证 (1-2小时)
----------------------------
1. 创建带检查点的测试地图
2. 测试顺序任务完成
3. 对比实验：有/无 FSA 引导

阶段 5: 文档更新
----------------
1. 更新 README
2. 添加使用示例


六、预期成果
================================================================================

1. 通用的任务描述能力
   - 用 LTL 公式描述任意顺序/条件任务
   - 换任务只需改配置文件

2. 清晰的职责分离
   - Safety: 形式化硬约束（绝对保证）
   - Task: FSA 引导 + RL 学习（灵活策略）

3. 可解释的任务进度
   - FSA 状态表示任务进度
   - 可以解释"当前在做什么"

4. 良好的复用性
   - 核心模块（LTL、FSA、Robustness）完全通用
   - 只需定义命题和公式即可适配新场景


七、待讨论问题
================================================================================

1. 观测空间选择
   - 方案 A: FSA 状态 one-hot
   - 方案 B: 当前子目标方向 + 进度 (推荐)
   - 方案 C: 混合
   
   你倾向哪种？

2. FSA 状态转移奖励
   - 固定值（如 +2）
   - 基于剩余子目标数递增
   - 基于 robustness
   
   你觉得哪种更合理？

3. 任务失败处理
   - 某些任务可能有"失败状态"（如超时、进入禁区）
   - 是否需要支持？

4. 多目标并行
   - 当前设计假设顺序任务
   - 是否需要支持 "F(a) & F(b)"（a 和 b 顺序任意）？

================================================================================
文档版本：v1.0
创建日期：2026-01-04
================================================================================
